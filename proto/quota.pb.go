// Code generated by protoc-gen-go. DO NOT EDIT.
// source: github.com/micro/quota-srv/proto/quota.proto

/*
Package quota is a generated protocol buffer package.

It is generated from these files:
	github.com/micro/quota-srv/proto/quota.proto

It has these top-level messages:
	AllocateRequest
	AllocateResponse
	Config
	Allocation
	Update
*/
package quota

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type AllocateResponse_Status int32

const (
	AllocateResponse_OK                       AllocateResponse_Status = 0
	AllocateResponse_REJECT_TOO_MANY_REQUESTS AllocateResponse_Status = 1
	AllocateResponse_REJECT_SERVER_ERROR      AllocateResponse_Status = 2
)

var AllocateResponse_Status_name = map[int32]string{
	0: "OK",
	1: "REJECT_TOO_MANY_REQUESTS",
	2: "REJECT_SERVER_ERROR",
}
var AllocateResponse_Status_value = map[string]int32{
	"OK": 0,
	"REJECT_TOO_MANY_REQUESTS": 1,
	"REJECT_SERVER_ERROR":      2,
}

func (x AllocateResponse_Status) String() string {
	return proto.EnumName(AllocateResponse_Status_name, int32(x))
}
func (AllocateResponse_Status) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{1, 0} }

type AllocateRequest struct {
	// name of the resource being used e.g api.maps
	Resource string `protobuf:"bytes,1,opt,name=resource" json:"resource,omitempty"`
	// shared bucket for the client e.g ip address, service name
	Bucket string `protobuf:"bytes,2,opt,name=bucket" json:"bucket,omitempty"`
	// resource allocation e.g 10 requests
	Allocation int64 `protobuf:"varint,3,opt,name=allocation" json:"allocation,omitempty"`
}

func (m *AllocateRequest) Reset()                    { *m = AllocateRequest{} }
func (m *AllocateRequest) String() string            { return proto.CompactTextString(m) }
func (*AllocateRequest) ProtoMessage()               {}
func (*AllocateRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *AllocateRequest) GetResource() string {
	if m != nil {
		return m.Resource
	}
	return ""
}

func (m *AllocateRequest) GetBucket() string {
	if m != nil {
		return m.Bucket
	}
	return ""
}

func (m *AllocateRequest) GetAllocation() int64 {
	if m != nil {
		return m.Allocation
	}
	return 0
}

type AllocateResponse struct {
	// status of this allocation
	Status AllocateResponse_Status `protobuf:"varint,1,opt,name=status,enum=AllocateResponse_Status" json:"status,omitempty"`
	// resource allocation provided
	Allocation int64 `protobuf:"varint,2,opt,name=allocation" json:"allocation,omitempty"`
}

func (m *AllocateResponse) Reset()                    { *m = AllocateResponse{} }
func (m *AllocateResponse) String() string            { return proto.CompactTextString(m) }
func (*AllocateResponse) ProtoMessage()               {}
func (*AllocateResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *AllocateResponse) GetStatus() AllocateResponse_Status {
	if m != nil {
		return m.Status
	}
	return AllocateResponse_OK
}

func (m *AllocateResponse) GetAllocation() int64 {
	if m != nil {
		return m.Allocation
	}
	return 0
}

// Config for the quota manager
type Config struct {
	// window over which to manage quota
	WindowSize int64 `protobuf:"varint,1,opt,name=window_size,json=windowSize" json:"window_size,omitempty"`
	// per second rate limit
	RateLimit int64 `protobuf:"varint,2,opt,name=rate_limit,json=rateLimit" json:"rate_limit,omitempty"`
	// total limit over the window
	TotalLimit int64 `protobuf:"varint,3,opt,name=total_limit,json=totalLimit" json:"total_limit,omitempty"`
	// ttl after which to expire idle bucket
	IdleTtl int64 `protobuf:"varint,4,opt,name=idle_ttl,json=idleTtl" json:"idle_ttl,omitempty"`
}

func (m *Config) Reset()                    { *m = Config{} }
func (m *Config) String() string            { return proto.CompactTextString(m) }
func (*Config) ProtoMessage()               {}
func (*Config) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *Config) GetWindowSize() int64 {
	if m != nil {
		return m.WindowSize
	}
	return 0
}

func (m *Config) GetRateLimit() int64 {
	if m != nil {
		return m.RateLimit
	}
	return 0
}

func (m *Config) GetTotalLimit() int64 {
	if m != nil {
		return m.TotalLimit
	}
	return 0
}

func (m *Config) GetIdleTtl() int64 {
	if m != nil {
		return m.IdleTtl
	}
	return 0
}

type Allocation struct {
	// name of the resource being used e.g api.maps
	Resource string `protobuf:"bytes,1,opt,name=resource" json:"resource,omitempty"`
	// shared bucket for the client e.g ip address, service name
	Bucket string `protobuf:"bytes,2,opt,name=bucket" json:"bucket,omitempty"`
	// total used e.g 10 requests
	Total int64 `protobuf:"varint,3,opt,name=total" json:"total,omitempty"`
	// time at which the allocation occurred. unix timestamp
	Timestamp int64 `protobuf:"varint,4,opt,name=timestamp" json:"timestamp,omitempty"`
}

func (m *Allocation) Reset()                    { *m = Allocation{} }
func (m *Allocation) String() string            { return proto.CompactTextString(m) }
func (*Allocation) ProtoMessage()               {}
func (*Allocation) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *Allocation) GetResource() string {
	if m != nil {
		return m.Resource
	}
	return ""
}

func (m *Allocation) GetBucket() string {
	if m != nil {
		return m.Bucket
	}
	return ""
}

func (m *Allocation) GetTotal() int64 {
	if m != nil {
		return m.Total
	}
	return 0
}

func (m *Allocation) GetTimestamp() int64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

type Update struct {
	// unique id of this update or the sender
	Id string `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	// time at which it was published
	Timestamp int64 `protobuf:"varint,2,opt,name=timestamp" json:"timestamp,omitempty"`
	// the allocations made
	Allocations []*Allocation `protobuf:"bytes,3,rep,name=allocations" json:"allocations,omitempty"`
}

func (m *Update) Reset()                    { *m = Update{} }
func (m *Update) String() string            { return proto.CompactTextString(m) }
func (*Update) ProtoMessage()               {}
func (*Update) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *Update) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Update) GetTimestamp() int64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *Update) GetAllocations() []*Allocation {
	if m != nil {
		return m.Allocations
	}
	return nil
}

func init() {
	proto.RegisterType((*AllocateRequest)(nil), "AllocateRequest")
	proto.RegisterType((*AllocateResponse)(nil), "AllocateResponse")
	proto.RegisterType((*Config)(nil), "Config")
	proto.RegisterType((*Allocation)(nil), "Allocation")
	proto.RegisterType((*Update)(nil), "Update")
	proto.RegisterEnum("AllocateResponse_Status", AllocateResponse_Status_name, AllocateResponse_Status_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for Quota service

type QuotaClient interface {
	Allocate(ctx context.Context, in *AllocateRequest, opts ...grpc.CallOption) (*AllocateResponse, error)
}

type quotaClient struct {
	cc *grpc.ClientConn
}

func NewQuotaClient(cc *grpc.ClientConn) QuotaClient {
	return &quotaClient{cc}
}

func (c *quotaClient) Allocate(ctx context.Context, in *AllocateRequest, opts ...grpc.CallOption) (*AllocateResponse, error) {
	out := new(AllocateResponse)
	err := grpc.Invoke(ctx, "/Quota/Allocate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Quota service

type QuotaServer interface {
	Allocate(context.Context, *AllocateRequest) (*AllocateResponse, error)
}

func RegisterQuotaServer(s *grpc.Server, srv QuotaServer) {
	s.RegisterService(&_Quota_serviceDesc, srv)
}

func _Quota_Allocate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AllocateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QuotaServer).Allocate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Quota/Allocate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QuotaServer).Allocate(ctx, req.(*AllocateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Quota_serviceDesc = grpc.ServiceDesc{
	ServiceName: "Quota",
	HandlerType: (*QuotaServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Allocate",
			Handler:    _Quota_Allocate_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "github.com/micro/quota-srv/proto/quota.proto",
}

func init() { proto.RegisterFile("github.com/micro/quota-srv/proto/quota.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 420 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x92, 0xcf, 0x6f, 0x94, 0x40,
	0x14, 0xc7, 0x0b, 0x58, 0xdc, 0x7d, 0x9b, 0x54, 0x1c, 0x8d, 0x62, 0x53, 0x75, 0xc3, 0x69, 0x0f,
	0x96, 0xd5, 0xf5, 0xe6, 0x6d, 0xd3, 0x10, 0x13, 0x7f, 0x91, 0x0e, 0xd4, 0xc4, 0x13, 0x99, 0x85,
	0xb1, 0x4e, 0x04, 0x86, 0x32, 0x0f, 0x9b, 0xf4, 0xec, 0xbf, 0xe3, 0xff, 0x68, 0x18, 0xc6, 0x52,
	0xe9, 0xad, 0x37, 0xbe, 0xdf, 0xef, 0x7b, 0x7c, 0x66, 0xe6, 0x3d, 0x78, 0x75, 0x2e, 0xf0, 0x47,
	0xb7, 0x0b, 0x73, 0x59, 0xad, 0x2b, 0x91, 0xb7, 0x72, 0x7d, 0xd1, 0x49, 0x64, 0xc7, 0xaa, 0xfd,
	0xb5, 0x6e, 0x5a, 0x89, 0x46, 0x87, 0xfa, 0x3b, 0xe0, 0xf0, 0x60, 0x5b, 0x96, 0x32, 0x67, 0xc8,
	0x29, 0xbf, 0xe8, 0xb8, 0x42, 0x72, 0x08, 0xb3, 0x96, 0x2b, 0xd9, 0xb5, 0x39, 0xf7, 0xad, 0xa5,
	0xb5, 0x9a, 0xd3, 0x6b, 0x4d, 0x9e, 0x80, 0xbb, 0xeb, 0xf2, 0x9f, 0x1c, 0x7d, 0x5b, 0x27, 0x46,
	0x91, 0x17, 0x00, 0x6c, 0xf8, 0x8d, 0x90, 0xb5, 0xef, 0x2c, 0xad, 0x95, 0x43, 0x6f, 0x38, 0xc1,
	0x1f, 0x0b, 0xbc, 0x91, 0xa3, 0x1a, 0x59, 0x2b, 0x4e, 0x5e, 0x83, 0xab, 0x90, 0x61, 0xa7, 0x34,
	0xe6, 0x60, 0xe3, 0x87, 0xd3, 0x92, 0x30, 0xd1, 0x39, 0x35, 0x75, 0x13, 0x8c, 0x7d, 0x0b, 0xf3,
	0x1e, 0xdc, 0xa1, 0x83, 0xb8, 0x60, 0xc7, 0x1f, 0xbd, 0x3d, 0x72, 0x04, 0x3e, 0x8d, 0x3e, 0x44,
	0x27, 0x69, 0x96, 0xc6, 0x71, 0xf6, 0x79, 0xfb, 0xe5, 0x5b, 0x46, 0xa3, 0xd3, 0xb3, 0x28, 0x49,
	0x13, 0xcf, 0x22, 0x4f, 0xe1, 0x91, 0x49, 0x93, 0x88, 0x7e, 0x8d, 0x68, 0x16, 0x51, 0x1a, 0x53,
	0xcf, 0x0e, 0x7e, 0x5b, 0xe0, 0x9e, 0xc8, 0xfa, 0xbb, 0x38, 0x27, 0x2f, 0x61, 0x71, 0x29, 0xea,
	0x42, 0x5e, 0x66, 0x4a, 0x5c, 0x0d, 0x2f, 0xe2, 0x50, 0x18, 0xac, 0x44, 0x5c, 0x71, 0xf2, 0x1c,
	0xa0, 0x65, 0xc8, 0xb3, 0x52, 0x54, 0x02, 0xcd, 0xa1, 0xe6, 0xbd, 0xf3, 0xa9, 0x37, 0xfa, 0x7e,
	0x94, 0xc8, 0x4a, 0x93, 0x9b, 0xb7, 0xd1, 0xd6, 0x50, 0xf0, 0x0c, 0x66, 0xa2, 0x28, 0x79, 0x86,
	0x58, 0xfa, 0xf7, 0x74, 0x7a, 0xbf, 0xd7, 0x29, 0x96, 0x01, 0x02, 0x6c, 0xaf, 0x6f, 0x77, 0xa7,
	0xc1, 0x3c, 0x86, 0x7d, 0x8d, 0x32, 0xdc, 0x41, 0x90, 0x23, 0x98, 0xa3, 0xa8, 0xb8, 0x42, 0x56,
	0x35, 0x86, 0x39, 0x1a, 0x01, 0x07, 0xf7, 0xac, 0x29, 0x18, 0x72, 0x72, 0x00, 0xb6, 0x28, 0x0c,
	0xcb, 0x16, 0xc5, 0xff, 0x7d, 0xf6, 0xa4, 0x8f, 0x1c, 0xc3, 0x62, 0x9c, 0x85, 0xf2, 0x9d, 0xa5,
	0xb3, 0x5a, 0x6c, 0x16, 0xe1, 0x78, 0x03, 0x7a, 0x33, 0xdf, 0xbc, 0x83, 0xfd, 0xd3, 0x7e, 0x13,
	0xc9, 0x1b, 0x98, 0xfd, 0x1b, 0x3c, 0xf1, 0xc2, 0xc9, 0x3a, 0x1e, 0x3e, 0xbc, 0xb5, 0x15, 0xc1,
	0xde, 0xce, 0xd5, 0xdb, 0xfb, 0xf6, 0x6f, 0x00, 0x00, 0x00, 0xff, 0xff, 0xe0, 0x75, 0xb0, 0x21,
	0xed, 0x02, 0x00, 0x00,
}
